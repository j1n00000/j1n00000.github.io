---
title: 2차 SQL injection 시큐어 코딩 및 실습
date: 2025-12-05 12:21 +09:00
categories: [웹해킹, SQL injection]
tags: [웹보안, 웹해킹, SQLi]
image:
  path: assets/img/250908/sqli1.png
---
<br>
## 2차 sql injection
---

<br>

입력값 받는 모든 곳에 선처리 질의문을 적용하기 전에, 2차 sqli가 어떤 식으로 작용하는지 확인만 해보려고 함.

(근데 괜히 한 듯 살짝 후회... 이거 때문에 귀찮게 게시글 수정 페이지 뭐 또 잘 안 돼서 고치는 데 시간 걸리고...<br>
올리는 것도 부끄러울 정도로 아주 사소한 이슈였음 GET 파라미터 값으로 게시글 번호 받아오는데...<br>
그걸 좋아요 기능에 쓰이는 파라미터 값으로 잘못 넣고 있었더라ㅎ)<br>



아무튼
회원 게시글 수정하는 페이지에서 세션


아래와 같은 상황에서 2차 sqli에 취약하다.
```
$username = $_SESSION['username'];

// prepared statement 없이 직접 삽입하는 경우!
$sql = "SELECT * FROM member WHERE username = '$username'";
$sql = "INSERT INTO login_log (username, time) VALUES ('$username', NOW())";
$sql = "DELETE FROM cart WHERE username = '$username'";
```


2차 sqli 대응방안...
1. 모든 쿼리에 Prepared Statement 사용
php// 항상 이렇게
$stmt = mysqli_prepare($mysqli, "UPDATE logindata SET address = ? WHERE username = ?");
mysqli_stmt_bind_param($stmt, 'ss', $new_address, $username);
2. 입력값 검증 (Defense in Depth)
php// 회원가입 시
if (!preg_match('/^[a-zA-Z0-9_]{3,20}$/', $username)) {
    die('유효하지 않은 사용자명');
}
3. DB에서 가져온 데이터도 신뢰하지 않기
php// DB에서 가져온 username도 다시 쿼리에 사용할 땐 prepared statement
$username = $_SESSION['username'];
$stmt = mysqli_prepare($mysqli, "SELECT * FROM orders WHERE username = ?");