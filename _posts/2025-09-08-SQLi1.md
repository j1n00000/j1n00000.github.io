---
title: SQL injection 시큐어 코딩 및 실습
date: 2025-09-08 02:13 +09:00
categories: [웹해킹, SQL injection]
tags: [웹보안, 웹해킹, SQLi]
image:
  path: assets/img/250908/sqli1.png
---
<br>
## SQLi 시큐어 코딩
---
<br>
아래는 예전에 만들었었던 로그인 페이지 코드이다.<br>

```php
<?php
// MySQL 연결
$dbhost = 'localhost';
$dbuser = 'test22';
$dbpass = 'pass22';
$dbname = 'logintest';
$conn = mysqli_connect($dbhost, $dbuser, $dbpass, $dbname);
if (!$conn) {
  die('Could not connect: ' . mysqli_error());
}

// POST 데이터 가져오기
$username = mysqli_real_escape_string($conn, $_POST['username']);
$password = mysqli_real_escape_string($conn, $_POST['password']);

// 사용자 정보 확인
$sql = "SELECT * FROM logindata WHERE username='$username' AND password='$password'";
$result = mysqli_query($conn, $sql);

if (mysqli_num_rows($result) == 1) {
  // 로그인 성공
  session_start();
  $_SESSION['username'] = $username;
  header('Location: index.php');
  exit;
} else {
  // 로그인 실패
  echo '<script>window.alert("로그인 실패")</script>';
  include 'login.php';
}
?>
```

<br>
음.. 입력값을 이스케이프 하고 있기는 하지만 여러모로 취약하다.<br>

오늘 목표는 해당 코드를 시큐어 코딩 한 후 다시 우회해보는 것...<br>

sql injection 대응방안으로 입력값 필터링 외에도 입력값 문자열 길이 제한 등등이 있지만<br>

가장 확실한 방안은 선처리 질의문(prepared statement)을 이용하는 것이다.<br>

prepared statement 는 질의문을 미리 컴파일 해두기 때문에 사용자 입력값에 따라 질의문이 악의적으로 변경될 일이 없다.<br>

이거 쓰면서 대충 생각해봤는데.. prepared statement를 다시 우회해서 공격할 방법이 있나...? 이게 되나..? 단순하게 sqli공격 단독으로는 절대 불가능하지 않나...? 아예 db 서버를 공격할 수 밖에 없지 않나...<br>

일단 시큐어코딩부터 해보고 생각하기로 함<br>




패스워드도 평문말고 해시로 저장하려고.. DB부터 바꿈<br>
<figure>
    <img src="assets/img/250908/sqli2.png" width="800" height="400" alt="Desktop View">
    <figcaption style="text-align: center; font-size: 0.9em; color: white;">
        logindata 테이블에 password_hash 컬럼 추가
  </figcaption>
</figure>


이후 로그인 처리하는 코드를 아래와 같이 수정했다.
```php
<?php
// MySQL 연결
$mysqli = mysqli_connect('localhost', 'test22', 'pass22', 'logintest');
if (!$mysqli) {
    die('DB connect error: ' . mysqli_connect_error());
}
mysqli_set_charset($mysqli, 'utf8mb4');

// 입력값 받아오기
$username = trim($_POST['username'] ?? '');
$password = $_POST['password'] ?? '';

if ($username === '' || $password === '') {
    echo '<script>window.alert("아이디/패스워드를 입력하세요")</script>';
    include 'login.php';
    exit;
}

// prepared statement 적용
$sql  = "SELECT password_hash FROM logindata WHERE username = ? LIMIT 1";
$stmt = mysqli_prepare($mysqli, $sql);
if (!$stmt) {
    die('Prepare failed: ' . mysqli_error($mysqli));
}

mysqli_stmt_bind_param($stmt, 's', $username);
if (!mysqli_stmt_execute($stmt)) {
    die('Execute failed: ' . mysqli_error($mysqli));
}

mysqli_stmt_bind_result($stmt, $hash);
$found = mysqli_stmt_fetch($stmt);
mysqli_stmt_free_result($stmt);
mysqli_stmt_close($stmt);

$ok = false;
if ($found && !empty($hash) && password_verify($password, $hash)) {
    $ok = true;
}

if ($ok) {
    session_start();
    session_regenerate_id(true);
    $_SESSION['username'] = $username;

    mysqli_close($mysqli);
    header('Location: index.php');
    exit;
} else {
    mysqli_close($mysqli);
    echo '<script>window.alert("로그인 실패")</script>';
    include 'login.php';
}
```

<br>
ai의 도움을 받아 완성ㅎㅎ..<br>
이제 웬만한 SQLi는 막히는데, 검색해보니 2차 SQLi도 있다고 한다.<br>
회원가입할 때 1차적으로 SQL 구문을 건드릴 수 있는... 텍스트의 계정을 생성한 후<br>
로그인할 때 2차적으로 DB 내에서 터지게끔? 하는 방식의 공격이라고 함.<br>

진짜 세상 똑똑한 사람들 많다.. 난 지식들 줏어먹으면서 감탄만 한다.<br>

일단 자야겠음 낼 해야지 넘 피곤

